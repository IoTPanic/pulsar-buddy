TODO

[x] don't futz with timers if nothing has changed
	- selecting a field currently results in a call to updateTimers()
	? delay call to updateTimers()
		- so users can scroll from 16/16 to 4/4 and have no change
	[] handled by only updating if a pending difference on measure boundries

[x] time update code - 9 micro s

[] check and Serial write (or other error) when periods out of range

[] speed up centerNumber by using the fixed size of digits in the font

[] field render for BPM
	- sideways
	- select selects from source menu:
		TAP - 1/4 - 1/16 - 24ppb 32ppb 48ppb



-- Slave clock

[] figure out how to use TC3 as a capture device
	- or move tuplet to TC3, and use TCC0
[] update and display bpm
	? fractional bpm display?
	? smoothing of display so user's don't freak out
	? update display at lower rate than tracker

[] master clock settings:
	- 1p, 2p, 4p, 24ppb, 32ppb, 48ppb

[] fixed BPM mode
	? UI for both setting fixed, and then BPM? adjusting BPM quickly

[] tap tempo
	? separate mode? or just part of fixed?




-- Memories

[x] field render of memories
[x] memory selection on select
[x] memory save on long press
[x] save memories to FLASH


[] time startup
[] time write
[] review hash
[] factor out write calls
[] review LOG calls
[] speed up first bitmap check
	- short circuit when non-zero




[] if no beats after X min... shut down display totally
	- fire back on when beat detected

QUESTIONS

[] if total reset length is kept under 4 x 4/4 (or even 8 x 8/1!)
	then all cycle counts in q fit in 16 bits

[] should tuplet load be sync'd to measure or full sequence?
[] should sequence length, when reloaded, be reset to first measure?


[] should BPM be kept in inverted form?
	- for display we want BPM
	- for calcs (see CpuClockDivisor()) we want inverted

[] why doesn't TCC1.WO1 on PAD_SPI_RX (pin 0, PA11) work?

================

Changes to settings and timing:

- Sequence Length -

setting:   n x c / u

	measure length (m) = c x q(u)
	total length (t) = n x c x q(u)

	q(1/4 note) = 10080
	q(1/8 note) =  5040
	etc...


state:
	measure (s) in [0..m)
	reset (r) in [0..t)

change n:
	s' = s
	r' = r mod t'

change c or u:
	s' = s mod m'
    r' = (r div m)*m' + s'
